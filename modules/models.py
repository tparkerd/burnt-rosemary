"""An analogous Python class for each table in GWAS database"""

class AutoRepr(object):
  def __repr__(self):
    items = ("%s = %r" % (k, v) for k, v in self.__dict__.items())
    return "<%s: {%s}>" % (self.__class__.__name__, ', '.join(items))

class species(AutoRepr):
  """Species class

  .. _species_class:

  :param shortname: *required.*
  :type shortname: string
  :param binomial: *required.*
  :type binomial: string
  :param subspecies:
  :type subspecies: string
  :param variety:
  :type variety: string

  """
  def __init__(self, shortname, binomial, subspecies, variety):
    self.n = shortname
    self.b = binomial
    self.s = subspecies
    self.v = variety


class population(AutoRepr):
  """Population class

  .. _population_class:

  :param population_name: *required.* human-readable name of population (often shorthand)
  :type population_name: string
  :param population_species: references :ref:`species_id <species_class>`
  :type population_species: integer
  """
  def __init__(self, population_name, population_species):
    self.n = population_name
    self.s = population_species


class line(AutoRepr):
  """Line class

  .. _line_class:

  :param line_name: *required.* name of line
  :type line_name: string
  :param line_population: *required.* references :ref:`population_id <population_class>`
  :type line_population: integer

  """
  def __init__(self, line_name, line_population):
    self.n = line_name
    self.p = line_population


class chromosome(AutoRepr):
  """Chromosome class

  .. _chromosome_class:

  :param chromosome_name: *required.* shorthand name of chromosome (often by number)
  :type chromosome_name: string
  :param chromosome_species: *required.* references :ref:`species_id <species_class>`
  :type chromosome_species: integer

  """
  def __init__(self, chromosome_name, chromosome_species):
    self.n = chromosome_name
    self.s = chromosome_species


class variant(AutoRepr):
  """Variant class

  .. _variant_class:

  :param variant_species: *required.* references :ref:`species_id <species_class>`
  :type variant_species: integer
  :param variant_chromosome: *required.* references :ref:`chromosome_id <chromosome_class>`
  :type variant_chromosome: integer
  :param variant_pos: *required.* position of the variant allele on chromsome
  :type variant_pos: integer

  """
  def __init__(self, variant_species, variant_chromosome, variant_pos):
    self.s = variant_species
    self.c = variant_chromosome
    self.p = variant_pos


class genotype(AutoRepr):
  """Genotype class

  .. _genotype_class:

  :param genotype_line: *required.* 
  :type genotype_line: integer
  :param genotype_chromosome: *required.* 
  :type genotype_chromosome: integer
  :param genotype: *required.* array of allele calls. Example value ``{0,0,0,-1,-1, ..., 0,0,0,0,2}``
  :type genotype: tinyint[]
  :comment: 
    .. container::
        :name: Details on genotype

        Example of possible 
        ``{0,0,0,-1,-1, ..., 0,0,0,0,2}``

        Each cell of the array contains an encoded value for allele call, and its meaing depends on the type of algorithm used. `Additional information on variant call format <https://en.wikipedia.org/wiki/Variant_Call_Format>`_. It's safe to assume that a value of ``-1`` is a missing call. Each value was generated by `vcftools <https://vcftools.github.io/man_latest.html>`_.
        At the time of authorship, the files used to generate them can be found on ``apollo`` at ``/shares/ibaxter_share/gziegler/Maize282_upliftedAGPv4``.
  """
  def __init__(self, genotype_line, genotype_chromosome, genotype, genotype_version):
    self.l = genotype_line
    self.c = genotype_chromosome
    self.g = genotype
    self.v = genotype_version

  def __repr__(self):
    # return "<%s: {%s}>" % (self.__class__.__name__, ', '.join(items))
    return "<%s: {%s}>" % (self.__class__.__name__, ', '.join([self.l, self.c, '*genotype*', self.v]))


class trait(AutoRepr):
  """Trait class

  .. _trait_class:

  :param trait_name: *required.* name of trait
  :type trait_name: string
  :param measurement_unit: unit of measure
  :type measurement_unit: string
  :param measurement_device: name of measurement device used to record trait
  :type measurement_device: string
  :param description: human-readable description of trait
  :type description: string

  """
  def __init__(self, trait_name, measurement_unit, measurement_device, description):
    self.n = trait_name
    self.u = measurement_unit
    self.m = measurement_device
    self.d = description


class phenotype(AutoRepr):
  """Phenotype class

  .. _phenotype_class:

  :param phenotype_line: *required.* references :ref:`line_id <line_class>`
  :type phenotype_line: integer
  :param phenotype_trait: *required.* references :ref:`traid_id <trait_class>`
  :type phenotype_trait: integer
  :param phenotype_value: *required.*
  :type phenotype_value: string

  """
  def __init__(self, phenotype_line, phenotype_trait, phenotype_value):
    self.l = phenotype_line
    self.t = phenotype_trait
    self.v = phenotype_value


class growout_type(AutoRepr):
  """Growout class

  .. _growout_type_class:

  :param growout_type: *required.* human-readable name of the type of medium used to grow plant
  :type growout_type: string

  """
  def __init__(self, growout_type):
    self.t = growout_type


class growout(AutoRepr):
  """Growout class

  .. _growout_class:

  :param growout_name: *required.* coded name of growout. It seems to be a two-initial code for state or country and last two digits of the year
  :type growout_name: string
  :param growout_population: *required.* references :ref:`population_id <population_class>`
  :type growout_population: integer
  :param growout_location: references :ref:`location_id <location_class>`
  :type growout_location: integer
  :param year: *required.*
  :type year: integer
  :param growout_growout_type: *required.* references :ref:`growout_type_id <growout_type_class>`
  :type growout_growout_type: integer

  """
  def __init__(self, growout_name, growout_population, growout_location, year, growout_growout_type):
    self.n = growout_name
    self.p = growout_population
    self.l = growout_location
    self.y = year
    self.t = growout_growout_type


class location(AutoRepr):
  """Location class

  .. _location_class:

  :param country: *required*.
  :type country: string
  :param state:
  :type state: string
  :param city:
  :type city: string
  :param code: *required.* Two character code for location
  :type code: integer

  """
  def __init__(self, country, state, city, code):
    self.c = country
    self.s = state
    self.i = city
    self.o = code


class gwas_algorithm(AutoRepr):
  """:abbr:`GWAS(Genome-wide association studies)` algorithm class

  .. _gwas_algorithm_class:

  :param gwas_algorithm: 
  :type gwas_algorithm: string

  """
  def __init__(self, gwas_algorithm):
    self.a = gwas_algorithm


class genotype_version(AutoRepr):
  """Genotype Version class

  .. _genotype_version_class:

  :param genotype_version_name: *required.*
  :type genotype_version_name: string
  :param genotype_version: *required.* 
  :type genotype_version: string
  :param reference_genome: *required.* references :ref:`line_id <line_class>`
  :type reference_genome: integer
  :param genotype_version_population: *required.* references :ref:`population_id <population_class>`
  :type genotype_version_population: integer

  """
  def __init__(self, genotype_version_name, genotype_version, reference_genome, genotype_version_population):
    self.n = genotype_version_name
    self.v = genotype_version
    self.r = reference_genome
    self.p = genotype_version_population


class imputation_method(AutoRepr):
  """Imputation Method class

  .. _imputation_method_class:

  :param imputation_method: *require.* type of imputation used
  :type imputation_method: string

  .. note::
    Need additional information on
    - imputation method (What is imputation?)

  """
  def __init__(self, imputation_method):
    self.m = imputation_method


class kinship_algorithm(AutoRepr):
  """Kinship Algorithm class

  .. _kinship_algorithm_class:

  :param kinship_algorithm: *required.* name of algorithm
  :type kinship_algorithm: string

  """
  def __init__(self, kinship_algorithm):
    self.a = kinship_algorithm


class kinship(AutoRepr):
  """Kinship class

  .. _kinship_class:

  :param kinship_algorithm: *required.* references :ref:`kinship_algorithm_id <kinship_algorithm>`
  :type kinship_algorithm: integer
  :param kinship_file_path: *required.* local path to kinship file
  :type kinship_file_path: string
  :comment: The file path is local to the machine running the database. Example path: ``/opt/BaxDB/file_storage/kinship_files/4.AstleBalding.synbreed.kinship.csv``

  """
  def __init__(self, kinship_algorithm, kinship_file_path):
    self.a = kinship_algorithm
    self.p = kinship_file_path

class population_structure_algorithm(AutoRepr):
  """Population Structure Algorithm class

  .. _population_structure_algorithm_class:

  :param population_structure_algorithm: *required.* human-readable name for algorithm
  :type population_structure_algorithm: string
  """
  def __init__(self, population_structure_algorithm):
    self.a = population_structure_algorithm

class population_structure(AutoRepr):
  """Population Stucture class

  .. _population_structure_class:

  :param population_structure_algorithm: *required* references :ref:`population_structure_algorithm_id <population_structure_algorithm_class>`
  :type population_structure_algorithm: integer
  :param population_structure_file_path: *required.* local path to population structure algorithm file
  :type population_structure_file_path: string
  :comment: The file path is local to the machine running the database. Example path: ``/opt/BaxDB/file_storage/population_structure_files/4.Eigenstrat.population.structure.10PCs.csv``
  """
  def __init__(self, population_structure_algorithm, population_structure_file_path):
    self.a = population_structure_algorithm
    self.p = population_structure_file_path

class gwas_run(AutoRepr):
  """:abbr:`GWAS(Genome-wide association studies)` Run class

  .. _gwas_run_class:


  :param gwas_run_trait: *required.* references :ref:`trait_id <trait_class>`
  :type gwas_run_trait: integer
  :param nsnps: *required.* number of SNPs
  :type nsnps: integer
  :param nlines: *required.* number of lines
  :type nlines: integer
  :param gwas_run_gwas_algorithm: *required.* references :ref:`gwas_algorithm_id <gwas_algorithm_class>`
  :type gwas_run_gwas_algorithm: integer
  :param gwas_run_genotype_version: *required.* references :ref:`genotype_version_id <genotype_version_class>`
  :type gwas_run_genotype_version: integer
  :param missing_snp_cutoff_value: *required.* SNP cutoff value for 
  :type missing_snp_cutoff_value: numeric
  :param missing_line_cutoff_value: *required.*
  :type missing_line_cutoff_value: numeric
  :param minor_allele_frequency_cutoff_value: *required.*
  :type minor_allele_frequency_cutoff_value: numeric
  :param gwas_run_imputation_method: *required.* references :ref:`imputation_method_id <imputation_method_class>`
  :type gwas_run_imputation_method: integer
  :param gwas_run_kinship: *required.* references :ref:`kinship_id <kinship_class>`
  :type gwas_run_kinship: integer
  :param gwas_run_population_structure: *required.* references :ref:`population_structure_id <population_structure_class>`
  :type gwas_run_population_structure: integer

  .. note::
    Needs additional information on
      - nsnps
      - nllines
      - snp cutoff value
      - line cutoff value
      - allele frequency cutoff value

  """
  def __init__(self, gwas_run_trait, nsnps, nlines, gwas_run_gwas_algorithm, gwas_run_genotype_version, missing_snp_cutoff_value, missing_line_cutoff_value, minor_allele_frequency_cutoff_value, gwas_run_imputation_method, gwas_run_kinship, gwas_run_population_structure):
    self.t = gwas_run_trait
    self.s = nsnps
    self.l = nlines
    self.a = gwas_run_gwas_algorithm
    self.v = gwas_run_genotype_version
    self.m = missing_snp_cutoff_value
    self.i = missing_line_cutoff_value
    self.n = minor_allele_frequency_cutoff_value
    self.p = gwas_run_imputation_method
    self.k = gwas_run_kinship
    self.o = gwas_run_population_structure

class gwas_result(AutoRepr):
  """:abbr:`GWAS(Genome-wide association studies)` Resultf class

  .. _gwas_result_class:

  :param gwas_result_chromosome: *required.*
  :type gwas_result_chromosome: integer
  :param basepair: *required.*
  :type basepair: integer
  :param gwas_result_gwas_run: *required.*
  :type gwas_result_gwas_run: integer
  :param pval:
  :type pval: numeric
  :param cofactor:
  :type cofactor: numeric
  :param _order:
  :type _order: numeric
  :param null_pval:
  :type null_pval: numeric
  :param model_added_pval:
  :type model_added_pval: numeric
  :param model:
  :type model: string
  :param pcs:
  :type pcs: integer[]

  .. note::
    Needs additional information on the
      - basepair (possible the number of bps, but of what? the chromosome or the snp, or what?)
      - pval (is this significance *p-value*?)
      - cofactor (???)
      - _order (???)
      - null_pval (is there a *p-value* for a null hypothesis?)
      - model_added_pval (???)
      - model (is this a call of models used? Where is a list?)
      - pcs (???) - in the Maize282, there are 18 different permutations of the pcs, comprised of 1-3 integers. Are they the chromosome found significant?

  """
  def __init__(self, gwas_result_chromosome, basepair, gwas_result_gwas_run, pval, cofactor, _order, null_pval, model_added_pval, model, pcs):
    self.c = gwas_result_chromosome
    self.b = basepair
    self.r = gwas_result_gwas_run
    self.p = pval
    self.o = cofactor
    self.d = _order
    self.n = null_pval
    self.a = model_added_pval
    self.m = model
    self.s = pcs
